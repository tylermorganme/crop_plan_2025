<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <style>
    * {
      box-sizing: border-box;
      font-family: Arial, sans-serif;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #f5f5f5;
    }

    body {
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #333;
    }

    #controls {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    button:hover {
      background: #3367d6;
    }

    button.toggle {
      background: #f1f1f1;
      color: #333;
      border: 1px solid #ddd;
    }

    button.toggle:hover {
      background: #e1e1e1;
    }

    button.toggle.active {
      background: #4285f4;
      color: white;
      border-color: #4285f4;
    }

    .toggle-group {
      display: flex;
      gap: 0;
    }

    .toggle-group button {
      border-radius: 0;
    }

    .toggle-group button:first-child {
      border-radius: 4px 0 0 4px;
    }

    .toggle-group button:last-child {
      border-radius: 0 4px 4px 0;
    }

    /* Timeline container */
    #timeline-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    /* Timeline header row */
    #timeline-header {
      display: flex;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
      flex-shrink: 0;
    }

    .header-label {
      width: 150px;
      min-width: 150px;
      padding: 8px;
      font-weight: bold;
      font-size: 11px;
      color: #666;
      border-right: 1px solid #ddd;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-group-controls {
      display: flex;
      gap: 2px;
    }

    .header-group-controls button {
      padding: 2px 5px;
      font-size: 10px;
      background: #e8e8e8;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
      color: #555;
    }

    .header-group-controls button:hover {
      background: #ddd;
      color: #333;
    }

    .header-scroll-wrapper {
      flex: 1;
      overflow: hidden;
    }

    .header-timeline {
      display: flex;
    }

    .month-header {
      flex-shrink: 0;
      text-align: center;
      font-size: 10px;
      color: #666;
      border-right: 1px solid #eee;
      padding: 4px 0;
    }

    .month-header .month-name {
      font-weight: bold;
    }

    /* Main scroll area */
    #scroll-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Fixed lane labels column - no independent scroll, synced with planner */
    #lane-labels {
      width: 150px;
      min-width: 150px;
      flex-shrink: 0;
      overflow: hidden;
      border-right: 1px solid #ddd;
      background: #fafafa;
    }

    #lane-labels-inner {
      will-change: transform;
    }

    /* Spacer to account for horizontal scrollbar in planner-scroll */
    .lane-labels-spacer {
      height: 17px;
      flex-shrink: 0;
    }

    .lane-label {
      padding: 0 8px;
      font-size: 11px;
      color: #333;
      font-weight: bold;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      height: 50px;
      box-sizing: border-box;
      flex-shrink: 0;
    }

    .lane-label:last-child {
      border-bottom: none;
    }

    /* Grouped lane label styles */
    .lane-label .group-prefix {
      font-size: 9px;
      color: #666;
      font-weight: normal;
      margin-right: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }

    .lane-label .group-prefix:hover {
      color: #333;
    }

    .lane-label .collapse-icon {
      font-size: 8px;
      margin-right: 2px;
      transition: transform 0.2s;
    }

    .lane-label .collapse-icon.collapsed {
      transform: rotate(90deg);
    }

    .lane-label .bed-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Alternating group backgrounds */
    .lane-label.group-even {
      background: #f0f4f8;
    }

    .resource-lane.group-even {
      background: #f8fafc;
    }

    .resource-lane.group-even.drag-over {
      background: #e3f2fd;
    }

    /* Collapsed group placeholder */
    .collapsed-group-label {
      padding: 0 8px;
      font-size: 11px;
      color: #666;
      font-style: italic;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      height: 28px;
      box-sizing: border-box;
      flex-shrink: 0;
      cursor: pointer;
      background: #f5f5f5;
    }

    .collapsed-group-label:hover {
      background: #eee;
    }

    .collapsed-group-label .collapse-icon {
      font-size: 8px;
      margin-right: 4px;
      transform: rotate(90deg);
    }

    .collapsed-group-lane {
      border-bottom: 1px solid #eee;
      height: 28px;
      flex-shrink: 0;
      box-sizing: border-box;
      background: #f5f5f5;
    }

    .collapsed-group-label.group-even {
      background: #e8eef4;
    }

    .collapsed-group-lane.group-even {
      background: #f0f4f8;
    }

    /* Scrollable planner area */
    #planner-scroll {
      flex: 1;
      overflow: auto;
    }

    #planner {
      display: flex;
      flex-direction: column;
    }

    /* Resource lanes */
    .resource-lane {
      border-bottom: 1px solid #eee;
      height: 50px;
      flex-shrink: 0;
      box-sizing: border-box;
    }

    .resource-lane:last-child {
      border-bottom: none;
    }

    .resource-lane.drag-over {
      background: #e3f2fd;
    }

    .lane-timeline {
      position: relative;
      height: 100%;
    }

    /* Grid lines for months */
    .grid-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #eee;
    }

    /* Crop boxes positioned absolutely on timeline */
    .crop-box {
      position: absolute;
      top: 8px;
      height: 34px;
      min-width: 30px;
      padding: 4px 8px;
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      border-radius: 4px;
      cursor: grab;
      font-size: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      user-select: none;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      z-index: 10;
    }

    .crop-box:hover {
      z-index: 20;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .crop-box.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .crop-box .crop-name {
      font-weight: bold;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .crop-box .crop-dates {
      font-size: 9px;
      opacity: 0.9;
    }

    /* Different colors for variety */
    .crop-box[data-index="0"] { background: linear-gradient(135deg, #4CAF50, #45a049); --crop-color: #4CAF50; }
    .crop-box[data-index="1"] { background: linear-gradient(135deg, #2196F3, #1976D2); --crop-color: #2196F3; }
    .crop-box[data-index="2"] { background: linear-gradient(135deg, #FF9800, #F57C00); --crop-color: #FF9800; }
    .crop-box[data-index="3"] { background: linear-gradient(135deg, #9C27B0, #7B1FA2); --crop-color: #9C27B0; }
    .crop-box[data-index="4"] { background: linear-gradient(135deg, #F44336, #D32F2F); --crop-color: #F44336; }
    .crop-box[data-index="5"] { background: linear-gradient(135deg, #00BCD4, #0097A7); --crop-color: #00BCD4; }
    .crop-box[data-index="6"] { background: linear-gradient(135deg, #795548, #5D4037); --crop-color: #795548; }
    .crop-box[data-index="7"] { background: linear-gradient(135deg, #607D8B, #455A64); --crop-color: #607D8B; }

    /* Overlapping crops - outline only */
    .crop-box.overlap {
      background: transparent !important;
      border: 2px solid var(--crop-color);
      color: #333;
      box-shadow: none;
    }

    .crop-box.overlap .crop-dates {
      opacity: 0.7;
    }

    .crop-box.overlap:hover {
      background: rgba(255,255,255,0.9) !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    #status {
      margin-top: 10px;
      font-size: 11px;
      color: #666;
    }

    /* Sync indicator */
    .sync-indicator {
      display: inline-block;
      font-size: 11px;
      color: #666;
      margin-left: 10px;
    }

    .sync-indicator::before {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
      background: #ccc;
    }

    .sync-indicator.syncing::before {
      background: #FFC107;
      animation: pulse 1s infinite;
    }

    .sync-indicator.synced::before {
      background: #4CAF50;
    }

    .sync-indicator.error::before {
      background: #F44336;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Highlight new/changed items */
    .crop-box.new-item {
      animation: highlight-new 2s ease-out;
    }

    .crop-box.changed-item {
      animation: highlight-change 1s ease-out;
    }

    @keyframes highlight-new {
      0% { box-shadow: 0 0 0 3px #4CAF50; }
      100% { box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    }

    @keyframes highlight-change {
      0% { box-shadow: 0 0 0 3px #2196F3; }
      100% { box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    }

    /* Loading placeholder */
    .loading-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: #666;
      font-size: 13px;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e0e0e0;
      border-top-color: #4285f4;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Today line */
    .today-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #F44336;
      z-index: 5;
    }

    /* Unassigned staging area */
    #unassigned-section {
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      margin-bottom: 8px;
      display: flex;
      flex-direction: column;
      min-height: 60px;
      flex-shrink: 0;
    }

    #unassigned-section.hidden {
      display: none;
    }

    #unassigned-header {
      display: flex;
      border-bottom: 1px solid #ddd;
      background: #fff8e1;
      flex-shrink: 0;
    }

    #unassigned-header .header-label {
      background: #fff8e1;
    }

    #unassigned-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    #unassigned-labels {
      width: 150px;
      min-width: 150px;
      flex-shrink: 0;
      border-right: 1px solid #ddd;
      background: #fffbf0;
      overflow: hidden;
    }

    #unassigned-labels-inner {
      will-change: transform;
    }

    .unassigned-lane-label {
      padding: 0 8px;
      font-size: 11px;
      color: #333;
      height: 50px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #eee;
      box-sizing: border-box;
    }

    #unassigned-scroll {
      flex: 1;
      overflow: auto;
    }

    #unassigned-planner {
      display: flex;
      flex-direction: column;
    }

    .unassigned-lane {
      position: relative;
      height: 50px;
      border-bottom: 1px solid #eee;
      box-sizing: border-box;
    }

    .unassigned-lane-timeline {
      position: relative;
      height: 100%;
    }

    /* Resize handle for unassigned section */
    #unassigned-resize {
      height: 6px;
      background: #f0f0f0;
      cursor: ns-resize;
      flex-shrink: 0;
      border-top: 1px solid #ddd;
    }

    #unassigned-resize:hover {
      background: #e0e0e0;
    }

    /* Warning icon for crops with unrecognized beds */
    .crop-box .warning-icon {
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 10px;
      color: #ff9800;
      text-shadow: 0 0 2px white;
    }

    .crop-box.has-warning {
      border: 2px solid #ff9800 !important;
      outline: 2px dashed #222;
      outline-offset: -2px;
    }

    /* Unassigned filter/sort controls */
    #unassigned-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: #fffbf0;
      border-bottom: 1px solid #eee;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    #unassigned-controls .control-group {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #unassigned-controls label {
      font-size: 10px;
      color: #666;
      font-weight: 500;
    }

    #unassigned-controls input[type="text"] {
      width: 120px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 11px;
    }

    #unassigned-controls input[type="text"]:focus {
      outline: none;
      border-color: #fb8c00;
    }

    #unassigned-controls input[type="text"]::placeholder {
      color: #aaa;
    }

    #unassigned-controls select {
      padding: 4px 6px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 11px;
      background: white;
      cursor: pointer;
    }

    #unassigned-controls select:focus {
      outline: none;
      border-color: #fb8c00;
    }

    #unassigned-controls .sort-btn {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 11px;
      background: white;
      color: #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    #unassigned-controls .sort-btn:hover {
      background: #f5f5f5;
      color: #111;
    }

    #unassigned-controls .sort-btn.active {
      background: #fff3e0;
      border-color: #fb8c00;
      color: #e65100;
    }

    #unassigned-controls .sort-arrow {
      font-size: 9px;
      color: inherit;
    }

    #unassigned-controls .clear-btn {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 10px;
      background: #f5f5f5;
      cursor: pointer;
      color: #666;
    }

    #unassigned-controls .clear-btn:hover {
      background: #eee;
      color: #333;
    }

    #unassigned-controls .divider {
      width: 1px;
      height: 20px;
      background: #ddd;
      margin: 0 4px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="resizeToFit()">Fit to Window</button>
    <div class="toggle-group">
      <button id="btn-overlap" class="toggle active" onclick="setViewMode('overlap')">Overlap</button>
      <button id="btn-stacked" class="toggle" onclick="setViewMode('stacked')">Stacked</button>
    </div>
    <div class="toggle-group">
      <button class="toggle" onclick="zoomOut()" title="Show more time">−</button>
      <button class="toggle" id="zoom-level" style="min-width: 70px; cursor: default;">6 Mon</button>
      <button class="toggle" onclick="zoomIn()" title="Show less time">+</button>
    </div>
    <button onclick="goToToday()">Today</button>
    <span id="sync-status" class="sync-indicator"></span>
  </div>

  <!-- Unassigned staging area -->
  <div id="unassigned-section" class="hidden">
    <div id="unassigned-header">
      <div class="header-label">
        <span>Unassigned</span>
        <span id="unassigned-count" style="font-weight: normal; color: #666;"></span>
      </div>
      <div class="header-scroll-wrapper">
        <div class="header-timeline" id="unassigned-header-months"></div>
      </div>
    </div>
    <div id="unassigned-controls">
      <div class="control-group">
        <input type="text" id="unassigned-search" placeholder="Search crops..." oninput="applyUnassignedFilters()">
      </div>
      <div class="divider"></div>
      <div class="control-group">
        <label>Start:</label>
        <select id="unassigned-start-filter" onchange="applyUnassignedFilters()">
          <option value="">Any</option>
        </select>
      </div>
      <div class="control-group">
        <label>End:</label>
        <select id="unassigned-end-filter" onchange="applyUnassignedFilters()">
          <option value="">Any</option>
        </select>
      </div>
      <div class="divider"></div>
      <div class="control-group">
        <label>Sort:</label>
        <button class="sort-btn active" id="sort-start" onclick="setUnassignedSort('start')" title="Sort by start date">
          Start <span class="sort-arrow">▲</span>
        </button>
        <button class="sort-btn" id="sort-end" onclick="setUnassignedSort('end')" title="Sort by end date">
          End <span class="sort-arrow">▲</span>
        </button>
        <button class="sort-btn" id="sort-name" onclick="setUnassignedSort('name')" title="Sort by name">
          Name <span class="sort-arrow">▲</span>
        </button>
      </div>
      <div class="divider"></div>
      <button class="clear-btn" onclick="clearUnassignedFilters()" title="Clear all filters">Clear</button>
    </div>
    <div id="unassigned-content">
      <div id="unassigned-labels">
        <div id="unassigned-labels-inner"></div>
      </div>
      <div id="unassigned-scroll">
        <div id="unassigned-planner"></div>
      </div>
    </div>
    <div id="unassigned-resize"></div>
  </div>

  <div id="timeline-container">
    <div id="timeline-header">
      <div class="header-label">
        <span>Bed</span>
        <span id="group-controls" class="header-group-controls" style="display: none;">
          <button onclick="expandAllGroups()" title="Expand all groups">▲</button>
          <button onclick="collapseAllGroups()" title="Collapse all groups">▼</button>
        </span>
      </div>
      <div class="header-scroll-wrapper">
        <div class="header-timeline" id="header-months"></div>
      </div>
    </div>
    <div id="scroll-container">
      <div id="lane-labels">
        <div id="lane-labels-inner"></div>
      </div>
      <div id="planner-scroll">
        <div id="planner">
          <div class="loading-placeholder">
            <div class="spinner"></div>
            <div>Connecting to spreadsheet...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="status">Loading...</div>

  <script>
    // ============================================================
    // DATA PROVIDER ABSTRACTION
    // Allows the UI to run with mock data in a browser for fast iteration
    // ============================================================

    // Mock data provider for local browser testing
    const mockProvider = {
      _prefs: {},
      _crops: [
        { id: 'crop_1', name: 'Tomatoes', startDate: '2025-04-01', endDate: '2025-07-15', resource: 'Bed 1', bgColor: '#e53935', textColor: '#ffffff' },
        { id: 'crop_2', name: 'Lettuce', startDate: '2025-03-15', endDate: '2025-05-01', resource: 'Bed 2', bgColor: '#43a047', textColor: '#ffffff' },
        { id: 'crop_3', name: 'Carrots', startDate: '2025-04-15', endDate: '2025-08-01', resource: 'Bed 1', bgColor: '#fb8c00', textColor: '#000000' },
        { id: 'crop_4', name: 'Peppers', startDate: '2025-05-01', endDate: '2025-09-30', resource: 'GH Bed 1', bgColor: '#8e24aa', textColor: '#ffffff' },
        { id: 'crop_5', name: 'Spinach', startDate: '2025-03-01', endDate: '2025-04-15', resource: '', bgColor: '#2e7d32', textColor: '#ffffff' },
        { id: 'crop_6', name: 'Kale', startDate: '2025-03-20', endDate: '2025-06-30', resource: 'Bed 2', bgColor: '#558b2f', textColor: '#ffffff' },
        { id: 'crop_7', name: 'Beans', startDate: '2025-05-15', endDate: '2025-08-15', resource: '' },
        { id: 'crop_8', name: 'Cucumbers', startDate: '2025-05-20', endDate: '2025-08-30', resource: 'Bed 3', bgColor: '#00897b', textColor: '#ffffff' },
        { id: 'crop_9', name: 'Squash', startDate: '2025-06-01', endDate: '2025-09-15', resource: 'GH Bed 1', bgColor: '#fdd835', textColor: '#000000' },
        { id: 'crop_10', name: 'Radishes', startDate: '2025-03-10', endDate: '2025-04-20', resource: 'Bed 3', bgColor: '#d81b60', textColor: '#ffffff' },
        { id: 'crop_11', name: 'Broccoli', startDate: '2025-04-01', endDate: '2025-06-15', resource: 'Bed4', bgColor: '#1565c0', textColor: '#ffffff' }
      ],
      _resources: ['Bed 1', 'Bed 2', 'Bed 3', 'GH Bed 1', 'GH Bed 2', 'Unassigned'],
      _groups: [
        { name: 'North Field', beds: ['Bed 1', 'Bed 2', 'Bed 3'] },
        { name: 'Greenhouse', beds: ['GH Bed 1', 'GH Bed 2'] },
        { name: null, beds: ['Unassigned'] }
      ],

      getPlannerData: function() {
        return Promise.resolve({
          resources: {
            resources: this._resources,
            groups: this._groups
          },
          crops: JSON.parse(JSON.stringify(this._crops)) // Deep copy
        });
      },

      getUserPreferences: function() {
        return Promise.resolve(this._prefs);
      },

      saveUserPreferences: function(prefs) {
        this._prefs = { ...this._prefs, ...prefs };
        console.log('[Mock] Saved preferences:', this._prefs);
        return Promise.resolve({ success: true });
      },

      updateCropResource: function(cropId, resource) {
        const crop = this._crops.find(c => c.id === cropId);
        if (crop) {
          crop.resource = resource;
          console.log('[Mock] Updated crop', cropId, 'to resource:', resource);
          return Promise.resolve({ success: true });
        }
        return Promise.resolve({ success: false, error: 'Crop not found' });
      },

      showPlannerWithSize: function(width, height) {
        console.log('[Mock] Resize requested:', width, 'x', height);
        return Promise.resolve();
      },

      closeDialog: function() {
        console.log('[Mock] Close dialog requested');
        return Promise.resolve();
      }
    };

    // Google Apps Script provider (wraps google.script.run)
    const googleProvider = {
      getPlannerData: function() {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getPlannerData();
        });
      },

      getUserPreferences: function() {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getUserPreferences();
        });
      },

      saveUserPreferences: function(prefs) {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .saveUserPreferences(prefs);
        });
      },

      updateCropResource: function(cropId, resource) {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .updateCropResource(cropId, resource);
        });
      },

      showPlannerWithSize: function(width, height) {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .showPlannerWithSize(width, height);
        });
      },

      closeDialog: function() {
        return new Promise((resolve) => {
          google.script.host.close();
          resolve();
        });
      }
    };

    // Select provider based on environment
    const isGoogleEnvironment = typeof google !== 'undefined' && google.script;
    const api = isGoogleEnvironment ? googleProvider : mockProvider;

    // Log which mode we're in
    if (!isGoogleEnvironment) {
      console.log('%c[MOCK MODE] Running with test data', 'color: orange; font-weight: bold');
    }

    // ============================================================
    // APPLICATION STATE
    // ============================================================

    let crops = [];
    let resources = [];       // Flat array of resource names
    let resourceGroups = null; // Array of { name, beds: [] } or null if no groups
    let collapsedGroups = new Set(); // Group names that are collapsed
    let pendingUpdates = new Map();
    let newItemIds = new Set();
    let changedItemIds = new Set();

    // View mode: 'overlap' or 'stacked'
    let viewMode = 'overlap';

    // Timeline state - now uses fixed range for infinite scroll
    let timelineStart = null;
    let timelineEnd = null;

    // Timeline configuration - semantic zoom levels based on time visible in viewport
    // Each level defines: label, and approximate days to show in viewport
    const ZOOM_LEVELS = [
      { label: '2 Yr', days: 730 },
      { label: '1 Yr', days: 365 },
      { label: '6 Mon', days: 180 },
      { label: '3 Mon', days: 90 },
      { label: '1 Mon', days: 30 }
    ];
    let zoomIndex = 2; // Start at 6 Mon
    let pixelsPerDay = 8; // Will be calculated based on viewport width
    const TIMELINE_PADDING_MONTHS = 12; // Months before earliest / after latest crop
    const DEFAULT_SCROLL_OFFSET_DAYS = 30; // Scroll to today - this many days

    // Constants for stacked view
    const CROP_HEIGHT = 34;
    const CROP_SPACING = 4;
    const CROP_TOP_PADDING = 8;

    // Track if initial scroll has been done
    let initialScrollDone = false;
    let savedScrollDate = null; // Date to scroll to from saved preferences

    // Unassigned section state
    let unassignedSectionHeight = 100; // Default height in pixels
    let unassignedSort = { field: 'start', asc: true };
    let unassignedSearchText = '';
    let unassignedStartFilter = '';
    let unassignedEndFilter = '';

    // Polling manager with guarded interval pattern
    const poller = {
      isPending: false,
      lastActivity: Date.now(),
      intervalId: null,
      TICK_RATE: isGoogleEnvironment ? 100 : 5000, // Slower polling in mock mode
      IDLE_TIMEOUT: 60000,

      init: function() {
        document.addEventListener('mousemove', () => this.lastActivity = Date.now());
        document.addEventListener('keydown', () => this.lastActivity = Date.now());
        document.addEventListener('mousedown', () => this.lastActivity = Date.now());
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden) this.lastActivity = Date.now();
        });
      },

      start: function() {
        if (this.intervalId) clearInterval(this.intervalId);
        this.intervalId = setInterval(() => this.tick(), this.TICK_RATE);
      },

      stop: function() {
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
        }
      },

      tick: function() {
        if (document.hidden) return;
        const isIdle = (Date.now() - this.lastActivity) > this.IDLE_TIMEOUT;
        if (isIdle && Math.random() > 0.1) return;
        if (this.isPending) return;
        this.executePoll();
      },

      executePoll: function() {
        this.isPending = true;

        api.getPlannerData()
          .then((data) => {
            this.isPending = false;
            // Handle both old format (array) and new format ({ resources, groups })
            if (Array.isArray(data.resources)) {
              resources = data.resources;
              resourceGroups = data.groups || null;
            } else {
              resources = data.resources.resources;
              resourceGroups = data.resources.groups || null;
            }
            mergeData(data.crops);
            render();
            setSyncStatus('synced', isGoogleEnvironment ? 'Live' : 'Mock');

            const assignedCount = crops.filter(c => c.resource && c.resource.trim()).length;
            document.getElementById('status').textContent =
              `${crops.length} crops (${assignedCount} assigned) · ${resources.length - 1} beds`;
          })
          .catch((err) => {
            this.isPending = false;
            setSyncStatus('error', 'Error');
            showError(err);
          });
      }
    };

    document.addEventListener('DOMContentLoaded', init);

    function init() {
      setSyncStatus('syncing', 'Connecting...');

      // Load user preferences first
      api.getUserPreferences()
        .then(function(prefs) {
          if (prefs.zoomIndex !== undefined) {
            zoomIndex = prefs.zoomIndex;
            updateZoomDisplay();
          }
          if (prefs.viewMode) {
            viewMode = prefs.viewMode;
            document.getElementById('btn-overlap').classList.toggle('active', viewMode === 'overlap');
            document.getElementById('btn-stacked').classList.toggle('active', viewMode === 'stacked');
          }
          if (prefs.scrollDate) {
            savedScrollDate = new Date(prefs.scrollDate);
          }
          if (prefs.collapsedGroups && Array.isArray(prefs.collapsedGroups)) {
            collapsedGroups = new Set(prefs.collapsedGroups);
          }
          if (prefs.unassignedSectionHeight !== undefined) {
            unassignedSectionHeight = prefs.unassignedSectionHeight;
          }
        })
        .catch(function() {
          // Ignore errors loading preferences, use defaults
        });

      poller.init();
      poller.executePoll();
      poller.start();

      // Sync horizontal scroll between header and planner
      const plannerScroll = document.getElementById('planner-scroll');
      const headerWrapper = document.querySelector('.header-scroll-wrapper');
      const laneLabels = document.getElementById('lane-labels');

      // Debounce timer for saving scroll position
      let scrollSaveTimeout = null;

      const laneLabelsInner = document.getElementById('lane-labels-inner');

      plannerScroll.addEventListener('scroll', () => {
        headerWrapper.scrollLeft = plannerScroll.scrollLeft;
        // Use transform for smooth sync without independent scrolling
        laneLabelsInner.style.transform = 'translateY(-' + plannerScroll.scrollTop + 'px)';

        // Sync unassigned section scroll
        const unassignedScroll = document.getElementById('unassigned-scroll');
        const unassignedHeaderWrapper = document.querySelector('#unassigned-header .header-scroll-wrapper');
        if (unassignedScroll) {
          unassignedScroll.scrollLeft = plannerScroll.scrollLeft;
        }
        if (unassignedHeaderWrapper) {
          unassignedHeaderWrapper.scrollLeft = plannerScroll.scrollLeft;
        }

        // Save scroll position (debounced to avoid too many saves)
        if (scrollSaveTimeout) clearTimeout(scrollSaveTimeout);
        scrollSaveTimeout = setTimeout(() => {
          if (timelineStart) {
            const leftDate = getLeftEdgeDate();
            api.saveUserPreferences({ scrollDate: leftDate.toISOString() });
          }
        }, 1000); // Save 1 second after scrolling stops
      });

      // Sync scroll from unassigned section to main planner
      const unassignedScroll = document.getElementById('unassigned-scroll');
      unassignedScroll.addEventListener('scroll', () => {
        // Horizontal sync
        plannerScroll.scrollLeft = unassignedScroll.scrollLeft;
        headerWrapper.scrollLeft = unassignedScroll.scrollLeft;
        const unassignedHeaderWrapper = document.querySelector('#unassigned-header .header-scroll-wrapper');
        if (unassignedHeaderWrapper) {
          unassignedHeaderWrapper.scrollLeft = unassignedScroll.scrollLeft;
        }
        // Vertical sync - sync labels with content
        const unassignedLabelsInner = document.getElementById('unassigned-labels-inner');
        if (unassignedLabelsInner) {
          unassignedLabelsInner.style.transform = 'translateY(-' + unassignedScroll.scrollTop + 'px)';
        }
      });

      // Set up resize handle for unassigned section
      setupUnassignedResize();

      // Recalculate on resize
      window.addEventListener('resize', () => {
        if (crops.length > 0) render();
      });
    }

    // Set up drag-to-resize for unassigned section
    function setupUnassignedResize() {
      const resizeHandle = document.getElementById('unassigned-resize');
      const unassignedSection = document.getElementById('unassigned-section');
      let isResizing = false;
      let startY = 0;
      let startHeight = 0;

      resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = unassignedSection.offsetHeight;
        document.body.style.cursor = 'ns-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        const newHeight = Math.max(60, Math.min(400, startHeight + deltaY));
        unassignedSectionHeight = newHeight;
        unassignedSection.style.height = newHeight + 'px';
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          // Save the new height
          api.saveUserPreferences({ unassignedSectionHeight: unassignedSectionHeight });
        }
      });
    }

    function startPolling() { poller.start(); }
    function stopPolling() { poller.stop(); }

    function mergeData(newData) {
      const oldMap = new Map(crops.map(c => [c.id, c]));

      newItemIds.clear();
      changedItemIds.clear();

      for (const crop of newData) {
        const old = oldMap.get(crop.id);
        if (!old) {
          newItemIds.add(crop.id);
        } else if (hasChanged(old, crop)) {
          if (!pendingUpdates.has(crop.id)) {
            changedItemIds.add(crop.id);
          }
        }
      }

      crops = newData.map(crop => {
        if (pendingUpdates.has(crop.id)) {
          return { ...crop, resource: pendingUpdates.get(crop.id) };
        }
        return crop;
      });
    }

    function hasChanged(oldCrop, newCrop) {
      return oldCrop.name !== newCrop.name ||
             oldCrop.resource !== newCrop.resource ||
             oldCrop.startDate !== newCrop.startDate ||
             oldCrop.endDate !== newCrop.endDate;
    }

    function setSyncStatus(state, text) {
      const el = document.getElementById('sync-status');
      el.className = 'sync-indicator ' + state;
      el.textContent = text;
    }

    function showError(err) {
      document.getElementById('status').textContent = 'Error: ' + (err.message || err);
      setSyncStatus('error', 'Error');
    }

    function resizeToFit() {
      stopPolling();
      const width = window.screen.availWidth - 100;
      const height = window.screen.availHeight - 150;

      api.showPlannerWithSize(width, height)
        .then(function() {
          api.closeDialog();
        });
    }

    function setViewMode(mode) {
      viewMode = mode;
      document.getElementById('btn-overlap').classList.toggle('active', mode === 'overlap');
      document.getElementById('btn-stacked').classList.toggle('active', mode === 'stacked');
      render();
      // Save preference
      api.saveUserPreferences({ viewMode: mode });
    }

    // Toggle group collapse state
    function toggleGroupCollapse(groupName) {
      if (collapsedGroups.has(groupName)) {
        collapsedGroups.delete(groupName);
      } else {
        collapsedGroups.add(groupName);
      }
      render();
      // Save preference
      api.saveUserPreferences({ collapsedGroups: Array.from(collapsedGroups) });
    }

    // Expand all groups
    function expandAllGroups() {
      collapsedGroups.clear();
      render();
      api.saveUserPreferences({ collapsedGroups: [] });
    }

    // Collapse all groups
    function collapseAllGroups() {
      if (resourceGroups) {
        resourceGroups.forEach(function(group) {
          if (group.name) {
            collapsedGroups.add(group.name);
          }
        });
        render();
        api.saveUserPreferences({ collapsedGroups: Array.from(collapsedGroups) });
      }
    }

    // Unassigned filter/sort functions
    function setUnassignedSort(field) {
      const btn = document.getElementById('sort-' + field);
      const arrow = btn.querySelector('.sort-arrow');

      if (unassignedSort.field === field) {
        // Toggle direction
        unassignedSort.asc = !unassignedSort.asc;
      } else {
        // New field, default to ascending
        unassignedSort.field = field;
        unassignedSort.asc = true;
      }

      // Update button states
      document.querySelectorAll('#unassigned-controls .sort-btn').forEach(b => {
        b.classList.remove('active');
        b.querySelector('.sort-arrow').textContent = '▲';
      });
      btn.classList.add('active');
      arrow.textContent = unassignedSort.asc ? '▲' : '▼';

      render();
    }

    function applyUnassignedFilters() {
      unassignedSearchText = document.getElementById('unassigned-search').value.toLowerCase().trim();
      unassignedStartFilter = document.getElementById('unassigned-start-filter').value;
      unassignedEndFilter = document.getElementById('unassigned-end-filter').value;
      render();
    }

    function clearUnassignedFilters() {
      document.getElementById('unassigned-search').value = '';
      document.getElementById('unassigned-start-filter').value = '';
      document.getElementById('unassigned-end-filter').value = '';
      unassignedSearchText = '';
      unassignedStartFilter = '';
      unassignedEndFilter = '';

      // Reset sort to default
      unassignedSort = { field: 'start', asc: true };
      document.querySelectorAll('#unassigned-controls .sort-btn').forEach(b => {
        b.classList.remove('active');
        b.querySelector('.sort-arrow').textContent = '▲';
      });
      document.getElementById('sort-start').classList.add('active');

      render();
    }

    function getMonthYear(dateStr) {
      const d = new Date(dateStr);
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return months[d.getMonth()] + ' ' + d.getFullYear();
    }

    function getFilteredSortedUnassignedCrops(unassignedCrops) {
      let filtered = unassignedCrops;

      // Apply text search filter
      if (unassignedSearchText) {
        filtered = filtered.filter(c => c.name.toLowerCase().includes(unassignedSearchText));
      }

      // Apply start date filter (by month-year)
      if (unassignedStartFilter) {
        filtered = filtered.filter(c => getMonthYear(c.startDate) === unassignedStartFilter);
      }

      // Apply end date filter (by month-year)
      if (unassignedEndFilter) {
        filtered = filtered.filter(c => getMonthYear(c.endDate) === unassignedEndFilter);
      }

      // Apply sorting
      filtered.sort((a, b) => {
        let cmp = 0;
        if (unassignedSort.field === 'start') {
          cmp = new Date(a.startDate).getTime() - new Date(b.startDate).getTime();
        } else if (unassignedSort.field === 'end') {
          cmp = new Date(a.endDate).getTime() - new Date(b.endDate).getTime();
        } else if (unassignedSort.field === 'name') {
          cmp = a.name.localeCompare(b.name);
        }
        return unassignedSort.asc ? cmp : -cmp;
      });

      return filtered;
    }

    function populateUnassignedFilterDropdowns(unassignedCrops) {
      const startFilter = document.getElementById('unassigned-start-filter');
      const endFilter = document.getElementById('unassigned-end-filter');

      // Collect unique month-years
      const startMonths = new Set();
      const endMonths = new Set();

      unassignedCrops.forEach(c => {
        startMonths.add(getMonthYear(c.startDate));
        endMonths.add(getMonthYear(c.endDate));
      });

      // Sort chronologically
      const sortMonths = (a, b) => {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const [am, ay] = a.split(' ');
        const [bm, by] = b.split(' ');
        if (ay !== by) return parseInt(ay) - parseInt(by);
        return months.indexOf(am) - months.indexOf(bm);
      };

      const sortedStartMonths = Array.from(startMonths).sort(sortMonths);
      const sortedEndMonths = Array.from(endMonths).sort(sortMonths);

      // Preserve current selections
      const currentStart = startFilter.value;
      const currentEnd = endFilter.value;

      // Rebuild dropdowns
      startFilter.innerHTML = '<option value="">Any</option>';
      sortedStartMonths.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        if (m === currentStart) opt.selected = true;
        startFilter.appendChild(opt);
      });

      endFilter.innerHTML = '<option value="">Any</option>';
      sortedEndMonths.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        if (m === currentEnd) opt.selected = true;
        endFilter.appendChild(opt);
      });
    }

    // Calculate stacking rows for crops in a lane
    // Returns a map of cropId -> row index (0-based)
    function calculateStackingRows(laneCrops) {
      if (laneCrops.length === 0) return { rows: {}, maxRow: 0 };

      // Sort by start date
      const sorted = [...laneCrops].sort((a, b) =>
        new Date(a.startDate).getTime() - new Date(b.startDate).getTime()
      );

      const rows = {};
      const rowEndTimes = []; // Track end time for each row

      for (const crop of sorted) {
        const startTime = new Date(crop.startDate).getTime();
        const endTime = new Date(crop.endDate).getTime();

        // Find the first row where this crop fits (no overlap)
        let assignedRow = -1;
        for (let r = 0; r < rowEndTimes.length; r++) {
          if (startTime > rowEndTimes[r]) {
            assignedRow = r;
            break;
          }
        }

        // If no existing row works, create a new one
        if (assignedRow === -1) {
          assignedRow = rowEndTimes.length;
          rowEndTimes.push(endTime);
        } else {
          rowEndTimes[assignedRow] = endTime;
        }

        rows[crop.id] = assignedRow;
      }

      return { rows, maxRow: rowEndTimes.length };
    }

    // Calculate timeline range - extended for infinite scroll
    function calculateTimelineRange() {
      const now = new Date();

      if (crops.length === 0) {
        // Default: 1 year before and after today
        timelineStart = new Date(now.getFullYear() - 1, 0, 1);
        timelineEnd = new Date(now.getFullYear() + 1, 11, 31);
        return;
      }

      let minDate = new Date(now); // Include today
      let maxDate = new Date(now);

      for (const crop of crops) {
        const start = new Date(crop.startDate);
        const end = new Date(crop.endDate);

        if (start < minDate) minDate = start;
        if (end > maxDate) maxDate = end;
      }

      // Add padding months before and after
      timelineStart = new Date(minDate.getFullYear(), minDate.getMonth() - TIMELINE_PADDING_MONTHS, 1);
      timelineEnd = new Date(maxDate.getFullYear(), maxDate.getMonth() + TIMELINE_PADDING_MONTHS + 1, 0);
    }

    // Get total timeline width in pixels
    function getTimelineWidth() {
      const days = Math.ceil((timelineEnd.getTime() - timelineStart.getTime()) / (1000 * 60 * 60 * 24));
      return days * pixelsPerDay;
    }

    // Get position and width in pixels (not percentages)
    // End date is treated as "through end of that day" (adds 1 day visually)
    function getTimelinePosition(startDate, endDate) {
      const startMs = new Date(startDate).getTime() - timelineStart.getTime();

      // Add 1 day to end date so it extends through the full last day
      const endDateObj = new Date(endDate);
      endDateObj.setDate(endDateObj.getDate() + 1);
      const endMs = endDateObj.getTime() - timelineStart.getTime();

      const msPerDay = 1000 * 60 * 60 * 24;
      const left = (startMs / msPerDay) * pixelsPerDay;
      const width = ((endMs - startMs) / msPerDay) * pixelsPerDay;

      return { left: Math.max(0, left), width: Math.max(1, width) };
    }

    // Render the unassigned staging area
    function renderUnassignedSection(timelineWidth, overlappingIds, validBeds) {
      const section = document.getElementById('unassigned-section');
      const planner = document.getElementById('unassigned-planner');
      const labelsInner = document.getElementById('unassigned-labels-inner');
      const headerMonths = document.getElementById('unassigned-header-months');
      const countEl = document.getElementById('unassigned-count');

      // Get unassigned crops (empty resource or unrecognized bed)
      const unassignedCrops = crops.filter(c => {
        const info = getEffectiveResource(c, validBeds);
        return info.effective === 'Unassigned';
      });

      // Show/hide section based on whether there are unassigned crops
      if (unassignedCrops.length === 0) {
        section.classList.add('hidden');
        return;
      }

      section.classList.remove('hidden');
      section.style.height = unassignedSectionHeight + 'px';

      // Populate filter dropdowns with available options
      populateUnassignedFilterDropdowns(unassignedCrops);

      // Apply filters and sorting
      const filteredCrops = getFilteredSortedUnassignedCrops(unassignedCrops);

      // Update count (show filtered/total)
      const unrecognizedCount = unassignedCrops.filter(c => {
        const info = getEffectiveResource(c, validBeds);
        return info.isUnrecognized;
      }).length;

      let countText = '';
      if (filteredCrops.length !== unassignedCrops.length) {
        countText = `(${filteredCrops.length}/${unassignedCrops.length}`;
      } else {
        countText = `(${unassignedCrops.length}`;
      }
      if (unrecognizedCount > 0) {
        countText += `, ${unrecognizedCount} ⚠)`;
      } else {
        countText += ')';
      }
      countEl.textContent = countText;

      // Clear and render header
      headerMonths.innerHTML = '';
      headerMonths.style.width = timelineWidth + 'px';

      const msPerDay = 1000 * 60 * 60 * 24;
      const current = new Date(timelineStart);
      while (current <= timelineEnd) {
        const monthStart = new Date(current);
        const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);
        const startMs = monthStart.getTime() - timelineStart.getTime();
        const endMs = Math.min(monthEnd.getTime(), timelineEnd.getTime()) - timelineStart.getTime();
        const days = (endMs - startMs) / msPerDay;
        const widthPx = days * pixelsPerDay;

        const monthEl = document.createElement('div');
        monthEl.className = 'month-header';
        monthEl.style.width = widthPx + 'px';

        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        monthEl.innerHTML = `<div class="month-name">${monthNames[current.getMonth()]}</div><div>${current.getFullYear()}</div>`;
        headerMonths.appendChild(monthEl);
        current.setMonth(current.getMonth() + 1);
      }

      // Clear planner and labels
      planner.innerHTML = '';
      labelsInner.innerHTML = '';
      planner.style.width = timelineWidth + 'px';

      // Render each filtered/sorted crop as its own lane (for vertical scrolling)
      filteredCrops.forEach(function(crop, index) {
        const info = getEffectiveResource(crop, validBeds);

        // Create label
        const label = document.createElement('div');
        label.className = 'unassigned-lane-label';
        label.textContent = crop.name;
        if (info.isUnrecognized) {
          label.innerHTML = crop.name + ' <span style="color: #ff9800;">⚠</span>';
          label.title = 'Unrecognized bed: "' + info.original + '"';
        }
        labelsInner.appendChild(label);

        // Create lane
        const lane = document.createElement('div');
        lane.className = 'unassigned-lane';
        lane.dataset.cropId = crop.id;

        const timeline = document.createElement('div');
        timeline.className = 'unassigned-lane-timeline';
        timeline.style.width = timelineWidth + 'px';

        // Add today line
        const today = new Date();
        if (today >= timelineStart && today <= timelineEnd) {
          const todayPos = getTimelinePosition(today, today);
          const todayLine = document.createElement('div');
          todayLine.className = 'today-line';
          todayLine.style.left = todayPos.left + 'px';
          timeline.appendChild(todayLine);
        }

        // Add crop box (always at row 0 since each crop has its own lane)
        const box = createCropBox(crop, index, overlappingIds, 0, info.isUnrecognized, info.original);
        timeline.appendChild(box);

        lane.appendChild(timeline);
        planner.appendChild(lane);
      });

      // Set up drop zone for the entire unassigned planner area
      planner.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.currentTarget.style.background = '#fff3e0';
      });

      planner.addEventListener('dragleave', function(e) {
        e.currentTarget.style.background = '';
      });

      planner.addEventListener('drop', function(e) {
        e.preventDefault();
        e.currentTarget.style.background = '';

        const cropId = e.dataTransfer.getData('text/plain');
        const crop = crops.find(c => c.id === cropId);
        const oldResource = crop ? crop.resource : '';

        if (crop) {
          crop.resource = ''; // Set to empty (unassigned)
          pendingUpdates.set(cropId, '');
        }
        render();
        document.getElementById('status').textContent = 'Saving...';

        api.updateCropResource(cropId, '')
          .then(function() {
            pendingUpdates.delete(cropId);
            document.getElementById('status').textContent = 'Moved to Unassigned';
          })
          .catch(function(err) {
            pendingUpdates.delete(cropId);
            if (crop) {
              crop.resource = oldResource;
            }
            render();
            document.getElementById('status').textContent = 'Error: ' + (err.message || err);
          });
      });
    }

    // Render month headers with pixel widths
    function renderHeader() {
      const headerEl = document.getElementById('header-months');
      headerEl.innerHTML = '';

      const timelineWidth = getTimelineWidth();
      headerEl.style.width = timelineWidth + 'px';

      const msPerDay = 1000 * 60 * 60 * 24;
      const current = new Date(timelineStart);

      while (current <= timelineEnd) {
        const monthStart = new Date(current);
        const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);

        const startMs = monthStart.getTime() - timelineStart.getTime();
        const endMs = Math.min(monthEnd.getTime(), timelineEnd.getTime()) - timelineStart.getTime();
        const days = (endMs - startMs) / msPerDay;
        const widthPx = days * pixelsPerDay;

        const monthEl = document.createElement('div');
        monthEl.className = 'month-header';
        monthEl.style.width = widthPx + 'px';

        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        monthEl.innerHTML = `<div class="month-name">${monthNames[current.getMonth()]}</div><div>${current.getFullYear()}</div>`;

        headerEl.appendChild(monthEl);

        current.setMonth(current.getMonth() + 1);
      }
    }

    // Get the set of valid bed names (excluding 'Unassigned')
    function getValidBedNames() {
      const validBeds = new Set();
      if (resourceGroups && resourceGroups.length > 0) {
        resourceGroups.forEach(function(group) {
          group.beds.forEach(function(bed) {
            if (bed !== 'Unassigned') {
              validBeds.add(bed);
            }
          });
        });
      } else {
        resources.forEach(function(r) {
          if (r !== 'Unassigned') {
            validBeds.add(r);
          }
        });
      }
      return validBeds;
    }

    // Determine effective resource for a crop (handles unrecognized beds)
    function getEffectiveResource(crop, validBeds) {
      const resource = (crop.resource || '').trim();
      if (!resource) {
        return { effective: 'Unassigned', isUnrecognized: false, original: '' };
      }
      if (validBeds.has(resource)) {
        return { effective: resource, isUnrecognized: false, original: resource };
      }
      // Unrecognized bed - treat as unassigned but flag it
      return { effective: 'Unassigned', isUnrecognized: true, original: resource };
    }

    function render() {
      calculatePixelsPerDay();
      calculateTimelineRange();
      renderHeader();

      // Show/hide group controls based on whether groups exist
      const groupControls = document.getElementById('group-controls');
      const hasGroups = resourceGroups && resourceGroups.some(g => g.name);
      groupControls.style.display = hasGroups ? 'inline-flex' : 'none';

      const timelineWidth = getTimelineWidth();

      // Get valid bed names for checking unrecognized beds
      const validBeds = getValidBedNames();

      // Detect overlapping crops (only used in overlap mode)
      const overlappingIds = findOverlappingCrops();

      // Render unassigned section first
      renderUnassignedSection(timelineWidth, overlappingIds, validBeds);

      const planner = document.getElementById('planner');
      const laneLabels = document.getElementById('lane-labels-inner');
      planner.innerHTML = '';
      laneLabels.innerHTML = '';

      // Set planner width to match timeline
      planner.style.width = timelineWidth + 'px';

      // Track group index for alternating colors
      let currentGroupIndex = 0;

      // Helper function to render a single resource lane
      // groupName is optional - if provided, shows group prefix with collapse toggle
      // groupIdx is used for alternating background colors
      // validBeds is used to check for unrecognized bed names
      function renderResourceLane(resource, groupName, groupIdx, validBeds) {
        // Create lane label (in fixed left column)
        const label = document.createElement('div');
        label.className = 'lane-label' + (groupIdx % 2 === 1 ? ' group-even' : '');
        label.dataset.resource = resource;

        // Get crops for this lane to calculate height
        // Match crops where effective resource equals this lane
        const laneCrops = crops.filter(c => {
          const info = getEffectiveResource(c, validBeds);
          return info.effective === resource;
        });

        // Calculate stacking if in stacked mode
        let stackInfo = { rows: {}, maxRow: 1 };
        let laneHeight = 50;
        if (viewMode === 'stacked' && laneCrops.length > 0) {
          stackInfo = calculateStackingRows(laneCrops);
          laneHeight = CROP_TOP_PADDING * 2 + stackInfo.maxRow * CROP_HEIGHT + (stackInfo.maxRow - 1) * CROP_SPACING;
        }

        label.style.height = laneHeight + 'px';

        // Build label content with optional group prefix
        if (groupName) {
          const isCollapsed = collapsedGroups.has(groupName);
          const prefix = document.createElement('span');
          prefix.className = 'group-prefix';
          prefix.innerHTML = '<span class="collapse-icon' + (isCollapsed ? ' collapsed' : '') + '">▲</span>' + groupName + ':';
          prefix.onclick = function(e) {
            e.stopPropagation();
            toggleGroupCollapse(groupName);
          };
          label.appendChild(prefix);

          const bedName = document.createElement('span');
          bedName.className = 'bed-name';
          bedName.textContent = resource;
          label.appendChild(bedName);
        } else {
          label.textContent = resource;
        }
        laneLabels.appendChild(label);

        // Create lane timeline (in scrollable area)
        const lane = document.createElement('div');
        lane.className = 'resource-lane' + (groupIdx % 2 === 1 ? ' group-even' : '');
        lane.dataset.resource = resource;
        lane.style.height = laneHeight + 'px';

        const timeline = document.createElement('div');
        timeline.className = 'lane-timeline';
        timeline.style.width = timelineWidth + 'px';

        // Add today line
        const today = new Date();
        if (today >= timelineStart && today <= timelineEnd) {
          const todayPos = getTimelinePosition(today, today);
          const todayLine = document.createElement('div');
          todayLine.className = 'today-line';
          todayLine.style.left = todayPos.left + 'px';
          timeline.appendChild(todayLine);
        }

        // Add crops - use effective resource for matching
        crops.forEach(function(crop, index) {
          const info = getEffectiveResource(crop, validBeds);
          if (info.effective === resource) {
            const stackRow = stackInfo.rows[crop.id] || 0;
            timeline.appendChild(createCropBox(crop, index, overlappingIds, stackRow, info.isUnrecognized, info.original));
          }
        });

        lane.appendChild(timeline);

        // Drop zone handlers
        lane.addEventListener('dragover', function(e) {
          e.preventDefault();
          lane.classList.add('drag-over');
        });

        lane.addEventListener('dragleave', function(e) {
          lane.classList.remove('drag-over');
        });

        lane.addEventListener('drop', function(e) {
          e.preventDefault();
          lane.classList.remove('drag-over');

          const cropId = e.dataTransfer.getData('text/plain');
          const newResource = lane.dataset.resource;
          const resourceValue = newResource === 'Unassigned' ? '' : newResource;

          const crop = crops.find(c => c.id === cropId);
          const oldResource = crop ? crop.resource : '';
          if (crop) {
            crop.resource = resourceValue;
            pendingUpdates.set(cropId, resourceValue);
          }
          render();
          document.getElementById('status').textContent = 'Saving...';

          api.updateCropResource(cropId, resourceValue)
            .then(function() {
              pendingUpdates.delete(cropId);
              document.getElementById('status').textContent = 'Saved to ' + newResource;
            })
            .catch(function(err) {
              pendingUpdates.delete(cropId);
              if (crop) {
                crop.resource = oldResource;
              }
              render();
              document.getElementById('status').textContent = 'Error: ' + (err.message || err);
            });
        });

        planner.appendChild(lane);
      }

      // Helper function to render a collapsed group placeholder
      function renderCollapsedGroupPlaceholder(groupName, bedCount, groupIdx) {
        // Create collapsed placeholder in lane labels
        const label = document.createElement('div');
        label.className = 'collapsed-group-label' + (groupIdx % 2 === 1 ? ' group-even' : '');
        label.innerHTML = '<span class="collapse-icon">▲</span>' + groupName + ' (' + bedCount + ' beds)';
        label.onclick = function() { toggleGroupCollapse(groupName); };
        laneLabels.appendChild(label);

        // Create matching placeholder in planner area
        const lane = document.createElement('div');
        lane.className = 'collapsed-group-lane' + (groupIdx % 2 === 1 ? ' group-even' : '');
        lane.style.width = timelineWidth + 'px';
        planner.appendChild(lane);
      }

      // Render resources - with groups if available, otherwise flat list
      // Note: Unassigned is now rendered in the separate staging area above
      if (resourceGroups && resourceGroups.length > 0) {
        // Render grouped resources
        let groupIdx = 0;
        resourceGroups.forEach(function(group) {
          if (group.name) {
            // This is a named group
            const isCollapsed = collapsedGroups.has(group.name);
            const thisGroupIdx = groupIdx;
            groupIdx++;

            if (isCollapsed) {
              // Show collapsed placeholder
              renderCollapsedGroupPlaceholder(group.name, group.beds.length, thisGroupIdx);
            } else {
              // Render beds with group prefix
              group.beds.forEach(function(bed) {
                renderResourceLane(bed, group.name, thisGroupIdx, validBeds);
              });
            }
          } else {
            // Ungrouped beds - render directly without group prefix
            // Skip 'Unassigned' as it's now in its own section
            group.beds.forEach(function(bed) {
              if (bed !== 'Unassigned') {
                renderResourceLane(bed, null, groupIdx, validBeds);
              }
            });
            groupIdx++;
          }
        });
      } else {
        // No groups - render flat list (skip Unassigned)
        resources.forEach(function(resource) {
          if (resource !== 'Unassigned') {
            renderResourceLane(resource, null, 0, validBeds);
          }
        });
      }

      // Add spacer to lane labels to account for horizontal scrollbar
      const spacer = document.createElement('div');
      spacer.className = 'lane-labels-spacer';
      laneLabels.appendChild(spacer);

      // Scroll to saved position or today - 30 days on initial load
      if (!initialScrollDone) {
        initialScrollDone = true;
        if (savedScrollDate) {
          scrollToDate(savedScrollDate);
        } else {
          scrollToDate(new Date(Date.now() - DEFAULT_SCROLL_OFFSET_DAYS * 24 * 60 * 60 * 1000));
        }
      }
    }

    // Scroll to a specific date
    function scrollToDate(date) {
      const plannerScroll = document.getElementById('planner-scroll');
      const msPerDay = 1000 * 60 * 60 * 24;
      const daysFromStart = (date.getTime() - timelineStart.getTime()) / msPerDay;
      const scrollX = daysFromStart * pixelsPerDay;
      plannerScroll.scrollLeft = Math.max(0, scrollX);
    }

    // Scroll to today (with offset)
    function goToToday() {
      scrollToDate(new Date(Date.now() - DEFAULT_SCROLL_OFFSET_DAYS * 24 * 60 * 60 * 1000));
    }

    // Get the date at the left edge of the viewport
    function getLeftEdgeDate() {
      const plannerScroll = document.getElementById('planner-scroll');
      const msPerDay = 1000 * 60 * 60 * 24;
      const daysFromStart = plannerScroll.scrollLeft / pixelsPerDay;
      return new Date(timelineStart.getTime() + daysFromStart * msPerDay);
    }

    // Get the date at the center of the current viewport
    function getCenterDate() {
      const plannerScroll = document.getElementById('planner-scroll');
      const centerX = plannerScroll.scrollLeft + plannerScroll.clientWidth / 2;
      const msPerDay = 1000 * 60 * 60 * 24;
      const daysFromStart = centerX / pixelsPerDay;
      return new Date(timelineStart.getTime() + daysFromStart * msPerDay);
    }

    // Scroll to center a specific date in the viewport
    function scrollToCenterDate(date) {
      const plannerScroll = document.getElementById('planner-scroll');
      const msPerDay = 1000 * 60 * 60 * 24;
      const daysFromStart = (date.getTime() - timelineStart.getTime()) / msPerDay;
      const targetX = daysFromStart * pixelsPerDay - plannerScroll.clientWidth / 2;
      plannerScroll.scrollLeft = Math.max(0, targetX);
    }

    // Calculate pixels per day based on current zoom level and viewport width
    function calculatePixelsPerDay() {
      const plannerScroll = document.getElementById('planner-scroll');
      const viewportWidth = plannerScroll ? plannerScroll.clientWidth : 800;
      const targetDays = ZOOM_LEVELS[zoomIndex].days;
      pixelsPerDay = Math.max(1, viewportWidth / targetDays);
    }

    // Update zoom level display
    function updateZoomDisplay() {
      document.getElementById('zoom-level').textContent = ZOOM_LEVELS[zoomIndex].label;
    }

    // Zoom in (show less time, more detail)
    function zoomIn() {
      if (zoomIndex >= ZOOM_LEVELS.length - 1) return;
      const centerDate = getCenterDate();
      zoomIndex++;
      calculatePixelsPerDay();
      updateZoomDisplay();
      render();
      scrollToCenterDate(centerDate);
      // Save preference
      api.saveUserPreferences({ zoomIndex: zoomIndex });
    }

    // Zoom out (show more time, less detail)
    function zoomOut() {
      if (zoomIndex <= 0) return;
      const centerDate = getCenterDate();
      zoomIndex--;
      calculatePixelsPerDay();
      updateZoomDisplay();
      render();
      scrollToCenterDate(centerDate);
      // Save preference
      api.saveUserPreferences({ zoomIndex: zoomIndex });
    }

    function createCropBox(crop, index, overlappingIds, stackRow, isUnrecognized, originalBed) {
      const pos = getTimelinePosition(crop.startDate, crop.endDate);

      const box = document.createElement('div');
      box.className = 'crop-box';
      box.draggable = true;
      box.dataset.id = crop.id;
      box.dataset.index = index % 8;

      box.style.left = pos.left + 'px';
      box.style.width = pos.width + 'px';

      // In stacked mode, position vertically based on row
      if (viewMode === 'stacked') {
        const topPos = CROP_TOP_PADDING + stackRow * (CROP_HEIGHT + CROP_SPACING);
        box.style.top = topPos + 'px';
      }

      // Check if this crop is overlapping (only in overlap mode)
      const isOverlapping = viewMode === 'overlap' && overlappingIds && overlappingIds.has(crop.id);

      // Apply custom colors from spreadsheet
      if (crop.bgColor) {
        // Custom background color - override the default gradient
        if (isOverlapping) {
          // In overlap mode: transparent background with colored border, black text
          box.style.background = 'transparent';
          box.style.border = '2px solid ' + crop.bgColor;
          box.style.color = '#333';
          box.classList.add('overlap');
          // Store color for hover state
          box.dataset.customColor = crop.bgColor;
        } else {
          // Solid fill mode: use the custom background and text colors from spreadsheet
          box.style.background = crop.bgColor;
          if (crop.textColor) {
            box.style.color = crop.textColor;
          }
          // If no textColor specified, keep the default white from CSS
        }
      } else {
        // No custom color - use default behavior
        if (isOverlapping) {
          box.classList.add('overlap');
        }
      }

      // Add warning styling for unrecognized bed
      if (isUnrecognized) {
        box.classList.add('has-warning');
        const warningIcon = document.createElement('span');
        warningIcon.className = 'warning-icon';
        warningIcon.textContent = '⚠';
        warningIcon.title = 'Unrecognized bed: "' + originalBed + '"';
        box.appendChild(warningIcon);
      }

      if (newItemIds.has(crop.id)) {
        box.classList.add('new-item');
      } else if (changedItemIds.has(crop.id)) {
        box.classList.add('changed-item');
      }

      const name = document.createElement('div');
      name.className = 'crop-name';
      name.textContent = crop.name;
      box.appendChild(name);

      const dates = document.createElement('div');
      dates.className = 'crop-dates';
      dates.textContent = formatDate(crop.startDate) + ' - ' + formatDate(crop.endDate);
      box.appendChild(dates);

      // Tooltip on hover - include warning about unrecognized bed
      let tooltip = `${crop.name}\n${formatDate(crop.startDate)} - ${formatDate(crop.endDate)}`;
      if (isUnrecognized) {
        tooltip += `\n⚠ Unrecognized bed: "${originalBed}"`;
      }
      box.title = tooltip;

      box.addEventListener('dragstart', function(e) {
        e.dataTransfer.setData('text/plain', crop.id);
        box.classList.add('dragging');
      });

      box.addEventListener('dragend', function(e) {
        box.classList.remove('dragging');
      });

      return box;
    }

    function formatDate(dateStr) {
      if (!dateStr) return '?';
      const d = new Date(dateStr);
      return (d.getMonth() + 1) + '/' + d.getDate();
    }

    // Detect which crops overlap within each resource lane
    function findOverlappingCrops() {
      const overlapping = new Set();

      // Group crops by resource
      const byResource = {};
      for (const crop of crops) {
        const resource = crop.resource || 'Unassigned';
        if (!byResource[resource]) byResource[resource] = [];
        byResource[resource].push(crop);
      }

      // Check for overlaps within each resource
      for (const resource in byResource) {
        const laneCrops = byResource[resource];

        for (let i = 0; i < laneCrops.length; i++) {
          for (let j = i + 1; j < laneCrops.length; j++) {
            const a = laneCrops[i];
            const b = laneCrops[j];

            const aStart = new Date(a.startDate).getTime();
            const aEnd = new Date(a.endDate).getTime();
            const bStart = new Date(b.startDate).getTime();
            const bEnd = new Date(b.endDate).getTime();

            // Check if date ranges overlap
            if (aStart <= bEnd && bStart <= aEnd) {
              overlapping.add(a.id);
              overlapping.add(b.id);
            }
          }
        }
      }

      return overlapping;
    }
  </script>
</body>
</html>
